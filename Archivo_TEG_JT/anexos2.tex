
\begin{lstlisting}[language=C++, caption=Tarea de recepción de datos de aceleración vía Lora en estación base]
    void receive_task(void *pvParameter)
    {
      while (true)
      {
        if (transmitFlag != true)
        {
          // reset flag
          receivedFlag = false;
    
          PacketUnion packetUnion;
    
          int numBytes = radio.getPacketLength();
          byte byteArr[numBytes];
    
          if (numBytes == 22)
          {
            Serial.println("Se recibio una actualizacion de SmartSensor.");
            data_o_comando = 1;
          }
          else if (numBytes == 131)
          {
            Serial.println("Se recibieron datos del SS.");
            data_o_comando = 0;
          }
          else if (numBytes == 28)
          {
            Serial.println("Se recibieron datos de temp y humedad.");
            data_o_comando = 2;
          }
          else
          {
            Serial.println("Se recibio algo que no es un comando ni una actualizacion de RTC.");
            datacorrupta = true;
          }
    
          Serial.print("Packet length: ");
          Serial.println(numBytes);
          int state = radio.readData(byteArr, numBytes);
    
          if (state == RADIOLIB_ERR_NONE || state == 0 && datacorrupta == false)
          {
            // packet was successfully received
            Serial.println(F("[SX1278] Paquete recibido!"));
    
            // Serial.print("Valor actual de datacomando> ");
            // Serial.println(data_o_comando);
    
            contador++;
    
            switch(data_o_comando)
            {
              case 0:
                  memcpy(&packetUnion.packet1, byteArr, sizeof(packetUnion.packet1));
    
                  Serial.print("[SX1278] Message ID: ");
                  Serial.println(packetUnion.packet1.messageID);
                  Serial.print("[SX1278] Sender ID: ");
                  Serial.println(packetUnion.packet1.senderID);
                  Serial.print("[SX1278] Receiver ID: ");
                  Serial.println(packetUnion.packet1.receiverID);
    
                  //Muestra payload
                  Serial.print(F("[SX1278] Payload:\t\t"));
                  //print the byte array
                  for (int i = 0; i < sizeof(packetUnion.packet1.payload); i+=4) {
                    float value = *((float*)(packetUnion.packet1.payload + i));
                    Serial.print(value);
                    Serial.print(F(" "));
                  }
                  Serial.println("");
    
                  leer_datos(sizeof(packetUnion.packet1.payload), packetUnion.packet1.messageID, packetUnion.packet1.senderID, packetUnion.packet1.receiverID, packetUnion.packet1.payload);
    
                  //ERA 95
                  if(packetUnion.packet1.messageID == (((NUM_DATOS * 4))*3 / 128) - 1){
                    if(xQueueSend(xQueueBufferACL, &buffer_prueba, portMAX_DELAY)){
                      Serial.println("Se envio la estructura bufferprueba a la cola xQueueBufferACL");
                      //vTaskResume(xHandle_send_mqtt);
                    }
                    else{
                      Serial.println("No se pudo enviar la estructura bufferprueba a la cola xQueueBufferACL");
                    }
                  }
    
                  break;
    
              case 1:
                  memcpy(&packetUnion.stringPacket, byteArr, numBytes);
                  Serial.println("El SS esta activo...");
    
                  Serial.print("[SX1278] Message ID: ");
                  Serial.println(packetUnion.stringPacket.messageID);
                  Serial.print("[SX1278] Sender ID: ");
                  Serial.println(packetUnion.stringPacket.senderID);
                  Serial.print("[SX1278] Receiver ID: ");
                  Serial.println(packetUnion.stringPacket.receiverID);
    
                  if(int(packetUnion.stringPacket.messageID) == 255){
                    Serial.println("Listo para enviar RTC...");
                    transmitFlag = true; //Activo bandera de envio
                    vTaskResume(xHandle_send_RTC_task);
                  }
                  break;
              case 2:
                  memcpy(&packetUnion.thipacket, byteArr, numBytes);
    
                  Serial.print("[SX1278] Message ID: ");
                  Serial.println(packetUnion.thipacket.messageID);
                  Serial.print("[SX1278] Sender ID: ");
                  Serial.println(packetUnion.thipacket.senderID);
                  Serial.print("[SX1278] Receiver ID: ");
                  Serial.println(packetUnion.thipacket.receiverID);
    
                  Serial.print(F("[SX1278] Payload:\t\t"));
                  //Print the temperature and humidity
                  Serial.print(F("Temperature: "));
                  Serial.print(packetUnion.thipacket.temperature);
                  Serial.print(F(" Humidity: "));
                  Serial.println(packetUnion.thipacket.humidity);
                  //Print the angle values
                  Serial.print(F("Yaw: "));
                  Serial.print(packetUnion.thipacket.yaw);
                  Serial.print(F(" Pitch: "));
                  Serial.print(packetUnion.thipacket.pitch);
                  Serial.print(F(" Roll: "));
                  Serial.println(packetUnion.thipacket.roll);
    
    
                  if(packetUnion.thipacket.messageID == 200){
                    if(xQueueSend(xQueueTempHumInc, &packetUnion.thipacket, portMAX_DELAY)){
                      Serial.println(xPortGetFreeHeapSize());
                      Serial.println("Se envio la estructura THI a la cola");
                      vTaskResume(xHandle_send_mqtt_thi);
                    }
                    else{
                      Serial.println("No se pudo enviar la estructura bufferprueba a la cola xQueueBufferACL");
                    }
                  }
                  break;
            }
    
    
          }
          else if (state == RADIOLIB_ERR_CRC_MISMATCH)
          {
            //Paquete recibido pero esta corrupto
            Serial.println(F("[SX1278] CRC error!"));
    
            // EJECUTAR CASO ESPECIAL DE DATA CORRUPTA PARA AUMENTAR CURRENTPOS Y GUARDAR 0s EN BUFFER DE INTERES
            if (numBytes == 131)
            {
              fillBuffer(bufferactual, NULL, sizeof(packetUnion.packet1.payload), true);
            }
            else
            {
              Serial.println("[SX1278] La data recibida esta corrupta y no es para este receptor");
            }
    
            contador_errores++;
          }
          else if (state == -1)
          {
            // some other error occurred
            Serial.print(F("[SX1278] Fallo, codigo "));
            Serial.println(state);
            contador_errores++;
          }
          else if (datacorrupta)
          {
            // some other error occurred
            Serial.print(F("[SX1278] Data corrupta..."));
            Serial.println(state);
            datacorrupta = false; ///Reinicio bandera
            contador_errores++;
          }
    
          Serial.print(F("[SX1278] Contador: "));
          Serial.println(contador);
          Serial.print(F("[SX1278] Contador error: "));
          Serial.println(contador_errores);
    
          Serial.println("");
        }
      else
      {
        Serial.println("Se estan enviando datos...");
      }
      vTaskSuspend(NULL);
      }
    }
    
    \end{lstlisting}

    
\begin{lstlisting}[language=C++, caption=Tarea para envío de actualización de RTC desde estación base]

    void send_RTC_task(void *pvParameters)
    {
      while (1)
      {
        if (transmitFlag == true)
        {
          Serial.print(F("[SX1278] Transmisitendo actualizacion de RTC... "));
    
          detachInterrupt(2);
    
          TimePacket packet;
    
          //Estructura de tiempo
          timestruct time_packet;
    
          struct tm timeinfo = rtc.getTimeStruct();
    
          time_packet.year = timeinfo.tm_year + 1900;
          time_packet.month = timeinfo.tm_mon + 1;
          time_packet.day = timeinfo.tm_mday;
          time_packet.hour = timeinfo.tm_hour;
          time_packet.minute = timeinfo.tm_min;
          time_packet.second = timeinfo.tm_sec;
    
          //Convierte estructura a byte array
          byte *byteArrTime = (byte *)&time_packet;
    
          //Muestra el payload
          Serial.print(F("[SX1278] Payload:\t\t"));
          //print the byte array
          // Print the byte array
          for (int i = 0; i < sizeof(time_packet); i++) {
              Serial.print(byteArrTime[i], HEX);
              Serial.print(F(" "));
          }
    
    
          Serial.println("");
    
          Serial.println(sizeof(time_packet));
    
          packet.messageID = 255;
          packet.senderID = 1;                                        
          packet.receiverID = 2;                                      
          memcpy(packet.payload, byteArrTime, sizeof(packet.payload));
    
          //Convierte estructura packet a byte array incluyendo encabezado
          byte *packetBytes = reinterpret_cast<byte *>(&packet);
    
          // Delay antes de transmitir para permitir que SS se configure en modo listening
          delay(500);
    
          int state = radio.startTransmit(packetBytes, sizeof(packet));
    
          if (state == RADIOLIB_ERR_NONE)
          {
            //Paquete transmitido con exito
            Serial.println(F(" exito!"));
          }
          else if (state == RADIOLIB_ERR_PACKET_TOO_LONG)
          {
            //Paquete mayor a 256 bytes
            Serial.println(F("muy largo!"));
          }
          else if (state == RADIOLIB_ERR_TX_TIMEOUT)
          {
            //timeout
            Serial.println(F("timeout!"));
          }
          else
          {
            //Otro error
            Serial.print(F("fallo, codigo "));
            Serial.println(state);
          }
    
          // Delay para permitir que se termine de enviar el paquete, no poner en modo receptor de inmediato
          delay(500);
    
          transmitFlag = false;
    
          Serial.print(F("[SX1278] Comienza a escuchar paquetes otra vez... \n"));
    
          int state2 = radio.startReceive();
    
          attachInterrupt(digitalPinToInterrupt(2), setFlag, RISING); // Reinicia ISR
    
          if (state2 == RADIOLIB_ERR_NONE)
          {
            Serial.println(F("Exito!"));
          }
          else
          {
            Serial.print(F("fallo, codigo "));
            Serial.println(state2);
            // while (true);
          }
    
          vTaskSuspend(NULL);
        }
        else
        {
          Serial.println("Se estan recibiendo datos en este momento...");
        }
      }
    }
    
    \end{lstlisting}

\begin{lstlisting}[language=C++, caption=Tarea de envio de datos de aceleración vía MQTT]

    
//Se activa una vez se reciben todos los paquetes Lora...
void send_mqtt(void *pvParameters){
    while(true){
        
        if(xQueueReceive(xQueueBufferACL, &bufferaceleracion, portMAX_DELAY)){
            Serial.println("Recibido de la cola BufferACL");
        } else {
            Serial.println("Error recibiendo de la cola BufferACL");
        }

        delay(500);

        sendAxis("esp32/x", "x", bufferaceleracion.bufferX, ARRAY_SIZE);
        sendAxis("esp32/y", "y", bufferaceleracion.bufferY, ARRAY_SIZE);
        sendAxis("esp32/z", "z", bufferaceleracion.bufferZ, ARRAY_SIZE);

        // Wait for some time before publishing again
        vTaskResume(xHandle_keepalive_task);
        vTaskSuspend(NULL);
    }
}

\end{lstlisting}


\begin{lstlisting}[language=C++, caption=Tarea de conversión a tipo JSON de un eje de aceleración]

void sendAxis(const char* topic, char* axis, const float* data, size_t dataSize) {
    DynamicJsonDocument doc(15000);

    //Crea arreglo JSON
    JsonArray array = doc.createNestedArray(axis);

    //Genera el arreglo a partir del float array
    for (size_t i = 0; i < dataSize; i++) {
        // Limit the float to 2 decimal places
        float value = round(data[i] * 100.0) / 100.0;
        array.add(value);
    }

    //Convierte el documento a string
    String json;
    serializeJson(doc, json);


    //Publica al topico escogido
    if(mqttClient.publish(topic, json.c_str()))
        {
            Serial.println("Mensaje publicado en topico MQTT");
        } else {
            Serial.println("Error publicando mensaje en topico MQTT");
        }
}

\end{lstlisting}


\begin{lstlisting}[language=C++, caption=Tarea de envío de datos de variables cuasi-estáticas vía MQTT]

    void send_mqtt_thi(void *pvParameter){
        while(1){
          vTaskSuspend(xHandle_keepalive_task);
      
          THIPacket thipacket;
      
          //Recibe arreglos de la cola
          if(xQueueReceive(xQueueTempHumInc, &thipacket, portMAX_DELAY)){
              Serial.println("Recibido de la cola TempHumInc");
          } else {
              Serial.println("Error recibiendo de la cola TempHumInc");
          }
      
          delay(200);
      
          sendTHI("esp32/temp", thipacket.temperature);
          sendTHI("esp32/hum", thipacket.humidity);
          sendTHI("esp32/inc_y", thipacket.yaw);
          sendTHI("esp32/inc_p", thipacket.pitch);
          sendTHI("esp32/inc_r", thipacket.roll);
          sendTHI("esp32/timestamp", (float)thipacket.timestamp);
      
          vTaskResume(xHandle_send_mqtt);
          vTaskSuspend(NULL);
        }
      }
      
\end{lstlisting}
    
\begin{lstlisting}[language=C++, caption=Tarea de callback ante recepción de datos MQTT]

    void messageReceived(char* topic, byte* payload, unsigned int length) {
        Serial.print("Mensaje recibido en topico: ");
        Serial.println(topic);
      
        // Step 2: Convert payload to string
        String message;
        for (int i = 0; i < length; i++) {
          message += (char)payload[i];
        }
      
        // Step 3: Check if the message is "ON"
        if (message == "ON") {
          // Step 4: Call the software ISR
          Serial.println("Peticion de datos via MQTT... Enviando paquete Lora si no se estan enviando datos");
          if(!transmitFlag){
            ISR_MQTT_Request();
          }
        }
      }    

    \end{lstlisting}
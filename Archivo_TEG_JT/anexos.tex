\begin{lstlisting}[language=C++, caption=Creación de tareas en FreeRTOS]
  void leerDatosACL(void *pvParameters){
      //Leer los valores del Acelerometro de la IMU
      while(true){
          mpu.getEvent(&a, &g, &tem);
          ACLData aclData; //Estructura a ser llenada con 3 ejes
    
          aclData.AclX = a.acceleration.x - acl_offset[0];
          aclData.AclY = a.acceleration.y - acl_offset[1]; 
          aclData.AclZ = a.acceleration.z - acl_offset[2];
    
          if(F_SAMPLING != 0){
            vTaskDelay(F_SAMPLING/portTICK_PERIOD_MS);
          }
          
          //Evaluo los valores actuales de aceleracion
          if(flag_limite == 0){
            flag_limite = evaluar_limites_acl(aclData.AclX, aclData.AclY, aclData.AclZ);
            flag_time = checktime();
            if(flag_limite != 0){
              flag_acl == true;
              globalTimestamp = getEpochTime();
              //Activando banderas para registro de temperatura y humedad
              flag_inc = 1;
              flag_temp_hum = 1;
    
              //Cambio en el LED de toma de datos
              digitalWrite(LED_EST1, HIGH);
              //Suspende tarea de LED IDLE
              vTaskSuspend(xHandle_blink);
            }
            if(flag_time){
              flag_limite = 1;
              flag_inc = 1;
              flag_temp_hum = 1;
              globalTimestamp = getEpochTime();
    
              //Cambio en el LED de toma de datos
              digitalWrite(LED_EST1, HIGH);
              //Suspende tarea de LED IDLE
              vTaskSuspend(xHandle_blink);
              }
          }
    
          //solo evalua si no se sobrepaso el limite al mismo tiempo
          if(flag_acl == true && flag_limite == 0){
              //Se cambia el valor de flag limite para solo ejecutar esto 1 vez
              flag_limite = 1;
              flag_inc = 1;
              flag_temp_hum = 1;
              globalTimestamp = getEpochTime();
    
              //Cambio en el LED de toma de datos
              digitalWrite(LED_EST1, HIGH);
              //Suspende tarea de LED IDLE
              vTaskSuspend(xHandle_blink);
          }
    
          //Envia los datos a la cola solo si se supero el limite
          if(flag_limite != 0 || flag_acl == true || flag_time == 1)
          {
            if(xQueueSend(aclQueue, &aclData, portMAX_DELAY)){
              vTaskResume(xHandle_crearBuffer); //Se llenan los buffers para enviar los datos
            }
            else{
              Serial.println("No se envió la cola...");
            }
          }
          else{
            continue;
          }
      }
    }
    
\end{lstlisting}

\begin{lstlisting}[language=C++, caption=Creación de tareas en FreeRTOS]

void crearBuffer(void *pvParameters){
  while(true){

    ACLData datos_acl;

    //Recibo los datos de la cola y los guardo en la estructura creada
    if(xQueueReceive(aclQueue, &datos_acl, portMAX_DELAY)){
      if( k <= NUM_DATOS ){
        if(k == 1) tiempo1 = millis();
        //Lleno el buffer de datos
        struct_buffer_acl.bufferX[k] = datos_acl.AclX;
        struct_buffer_acl.bufferY[k] = datos_acl.AclY;
        struct_buffer_acl.bufferZ[k] = datos_acl.AclZ;
        k++;
      }
      else{
        //Reiniciando para sobreescribir en buffers "nuevos" en la siguiente accion
        k = 0;
        cont2 = 0;
        cont2_inc = 0;

        //Se siguen tomando datos mas no se guardan en los buffers
        flag_limite = 0;
        flag_inc = 0;
        flag_temp_hum = 0;
        flag_time = 0;
        flag_acl = false; //Reinicio booleano de recepcion LoRa para toma de decisiones en proxima peticion

        //Apago led indicativo de toma de datos
        digitalWrite(LED_EST1, LOW);


        //Envio los resultados a la cola
        if(xQueueSend(tramaLoRaQueue, &struct_buffer_acl, portMAX_DELAY)){
           vTaskSuspend(xHandle_leerDatosACL); //suspendo adquisicion hasta que se envie todo
           vTaskSuspend(xHandle_readBMETask);
           vTaskSuspend(xHandle_readMPU9250);

          //Se envian los datos mediante lora
          vTaskResume(xHandle_send_packet);
        }
        else{
          Serial.println("No se envio la cola...");
        }

        vTaskResume(xHandle_blink);
      }
    }
    else{
      Serial.println("No se recibio la cola correctamente...");
    };

    //vPortFree(NULL);
 
    //Se suspende esta tarea para esperar la toma de datos
    vTaskSuspend(xHandle_crearBuffer);

  }
}

\end{lstlisting}


\begin{lstlisting}[language=C++, caption=Creación de tareas en FreeRTOS]

void send_RTC_task(void *pvParameters)
{
  while (1)
  {
    if (transmitFlag == true)
    {
      Serial.print(F("[SX1278] Transmitting RTC update... "));

      detachInterrupt(2);

      // LORA PACKET TO BE SENT
      TimePacket packet;

      // TIME PACKET STRUCTURE
      timestruct time_packet;
      // Fill the time_packet structure with current time
      struct tm timeinfo = rtc.getTimeStruct();

      time_packet.year = timeinfo.tm_year + 1900;
      time_packet.month = timeinfo.tm_mon + 1;
      time_packet.day = timeinfo.tm_mday;
      time_packet.hour = timeinfo.tm_hour;
      time_packet.minute = timeinfo.tm_min;
      time_packet.second = timeinfo.tm_sec;

      Serial.print("Year: ");
      Serial.print(time_packet.year);
      Serial.print(". Month: ");
      Serial.print(time_packet.month);
      Serial.print(". Day: ");
      Serial.print(time_packet.day);
      Serial.print(". Hour: ");
      Serial.print(time_packet.hour);
      Serial.print(". Minute: ");
      Serial.print(time_packet.minute);
      Serial.print(". Second: ");
      Serial.println(time_packet.second);

      // Convert the time_packet structure to a byte array
      byte *byteArrTime = (byte *)&time_packet;

      //Print the payload
      //print data of the packet
      Serial.print(F("[SX1278] Payload:\t\t"));
      //print the byte array
      // Print the byte array
      for (int i = 0; i < sizeof(time_packet); i++) {
          Serial.print(byteArrTime[i], HEX);
          Serial.print(F(" "));
      }


      Serial.println("");

      Serial.print(F("El tamaño del payload de tiempo es: "));
      Serial.println(sizeof(time_packet));

      packet.messageID = 255;
      packet.senderID = 1;                                         // Set your sender ID
      packet.receiverID = 2;                                       // Set the intended receiver ID
      memcpy(packet.payload, byteArrTime, sizeof(packet.payload)); // Copy the byte array into the payload

      // Convert the Packet struct to a byte array (ESTRUCTURA A ENVIAR POR LORA)
      byte *packetBytes = reinterpret_cast<byte *>(&packet);

      // Delay antes de transmitir para permitir que SS se ponga en modo listening
      delay(500);

      int state = radio.startTransmit(packetBytes, sizeof(packet));

      if (state == RADIOLIB_ERR_NONE)
      {
        // the packet was successfully transmitted
        Serial.println(F(" success!"));
      }
      else if (state == RADIOLIB_ERR_PACKET_TOO_LONG)
      {
        // the supplied packet was longer than 256 bytes
        Serial.println(F("muy largo!"));
      }
      else if (state == RADIOLIB_ERR_TX_TIMEOUT)
      {
        // timeout occurred while transmitting packet
        Serial.println(F("timeout!"));
      }
      else
      {
        // some other error occurred
        Serial.print(F("fallo, codigo "));
        Serial.println(state);
      }

      // Delay para permitir que se termine de enviar el paquete, no poner en modo receptor de inmediato
      delay(500);

      transmitFlag = false;

      Serial.print(F("[SX1278] Comienza a escuchar paquetes otra vez... \n"));

      int state2 = radio.startReceive();

      attachInterrupt(digitalPinToInterrupt(2), setFlag, RISING); // Reinicia ISR

      if (state2 == RADIOLIB_ERR_NONE)
      {
        Serial.println(F("Exito!"));
      }
      else
      {
        Serial.print(F("fallo, codigo "));
        Serial.println(state2);
        // while (true);
      }

      vTaskSuspend(NULL);
    }
    else
    {
      Serial.println("Se estan recibiendo datos en este momento...");
    }
  }
}

\end{lstlisting}


\begin{lstlisting}[language=C++, caption=Tarea de recepción de datos de aceleración vía Lora en estación base]
void receive_task(void *pvParameter)
{
  while (true)
  {
    if (transmitFlag != true)
    {
      // reset flag
      receivedFlag = false;

      PacketUnion packetUnion;

      // Packet packet;

      // you can also read received data as byte array
      int numBytes = radio.getPacketLength();
      byte byteArr[numBytes]; // El de mayor tamaño

      // Serial.print("Valor actual de datacomando> ");
      // Serial.println(data_o_comando);

      if (numBytes == 22)
      {
        Serial.println("Se recibio una actualizacion de SmartSensor.");
        data_o_comando = 1;
      }
      else if (numBytes == 131)
      {
        Serial.println("Se recibieron datos del SS.");
        data_o_comando = 0;
      }
      else if (numBytes == 28)
      {
        Serial.println("Se recibieron datos de temp y humedad.");
        data_o_comando = 2;
      }
      else
      {
        Serial.println("Se recibio algo que no es un comando ni una actualizacion de RTC.");
        datacorrupta = true;
        //vTaskSuspend(NULL); // Ignore if it's larger than TimePacket
      }

      Serial.print("Packet length: ");
      Serial.println(numBytes);
      int state = radio.readData(byteArr, numBytes);

      if (state == RADIOLIB_ERR_NONE || state == 0 && datacorrupta == false)
      {
        // packet was successfully received
        Serial.println(F("[SX1278] Paquete recibido!"));

        // Serial.print("Valor actual de datacomando> ");
        // Serial.println(data_o_comando);

        contador++;

        switch(data_o_comando)
        {
          case 0:
              memcpy(&packetUnion.packet1, byteArr, sizeof(packetUnion.packet1));

              Serial.print("[SX1278] Message ID: ");
              Serial.println(packetUnion.packet1.messageID);
              Serial.print("[SX1278] Sender ID: ");
              Serial.println(packetUnion.packet1.senderID);
              Serial.print("[SX1278] Receiver ID: ");
              Serial.println(packetUnion.packet1.receiverID);

              //print data of the packet
              Serial.print(F("[SX1278] Payload:\t\t"));
              //print the byte array
              for (int i = 0; i < sizeof(packetUnion.packet1.payload); i+=4) {
                float value = *((float*)(packetUnion.packet1.payload + i));
                Serial.print(value);
                Serial.print(F(" "));
              }
              Serial.println("");

              leer_datos(sizeof(packetUnion.packet1.payload), packetUnion.packet1.messageID, packetUnion.packet1.senderID, packetUnion.packet1.receiverID, packetUnion.packet1.payload);

              //ERA 95
              if(packetUnion.packet1.messageID == (((NUM_DATOS * 4))*3 / 128) - 1){
                if(xQueueSend(xQueueBufferACL, &buffer_prueba, portMAX_DELAY)){
                  Serial.println("Se envio la estructura bufferprueba a la cola xQueueBufferACL");
                  //vTaskResume(xHandle_send_mqtt);
                }
                else{
                  Serial.println("No se pudo enviar la estructura bufferprueba a la cola xQueueBufferACL");
                }
              }

              break;

          case 1:
              memcpy(&packetUnion.stringPacket, byteArr, numBytes);
              Serial.println("El SS esta activo...");

              Serial.print("[SX1278] Message ID: ");
              Serial.println(packetUnion.stringPacket.messageID);
              Serial.print("[SX1278] Sender ID: ");
              Serial.println(packetUnion.stringPacket.senderID);
              Serial.print("[SX1278] Receiver ID: ");
              Serial.println(packetUnion.stringPacket.receiverID);

              if(int(packetUnion.stringPacket.messageID) == 255){
                Serial.println("Listo para enviar RTC...");
                transmitFlag = true; //Activo bandera de envio
                vTaskResume(xHandle_send_RTC_task);
              }
              break;
          case 2:
              memcpy(&packetUnion.thipacket, byteArr, numBytes);

              Serial.print("[SX1278] Message ID: ");
              Serial.println(packetUnion.thipacket.messageID);
              Serial.print("[SX1278] Sender ID: ");
              Serial.println(packetUnion.thipacket.senderID);
              Serial.print("[SX1278] Receiver ID: ");
              Serial.println(packetUnion.thipacket.receiverID);

              Serial.print(F("[SX1278] Payload:\t\t"));
              //Print the temperature and humidity
              Serial.print(F("Temperature: "));
              Serial.print(packetUnion.thipacket.temperature);
              Serial.print(F(" Humidity: "));
              Serial.println(packetUnion.thipacket.humidity);
              //Print the angle values
              Serial.print(F("Yaw: "));
              Serial.print(packetUnion.thipacket.yaw);
              Serial.print(F(" Pitch: "));
              Serial.print(packetUnion.thipacket.pitch);
              Serial.print(F(" Roll: "));
              Serial.println(packetUnion.thipacket.roll);


              if(packetUnion.thipacket.messageID == 200){
                if(xQueueSend(xQueueTempHumInc, &packetUnion.thipacket, portMAX_DELAY)){
                  Serial.println(xPortGetFreeHeapSize());
                  Serial.println("Se envio la estructura THI a la cola");
                  vTaskResume(xHandle_send_mqtt_thi);
                }
                else{
                  Serial.println("No se pudo enviar la estructura bufferprueba a la cola xQueueBufferACL");
                }
              }
              break;
        }


      }
      else if (state == RADIOLIB_ERR_CRC_MISMATCH)
      {
        // packet was received, but is malformed
        Serial.println(F("[SX1278] CRC error!"));

        // EJECUTAR CASO ESPECIAL DE DATA CORRUPTA PARA AUMENTAR CURRENTPOS Y GUARDAR 0s EN BUFFER DE INTERES
        if (numBytes == 131)
        {
          fillBuffer(bufferactual, NULL, sizeof(packetUnion.packet1.payload), true);
        }
        else
        {
          Serial.println("[SX1278] La data recibida esta corrupta y no es para este receptor");
        }

        contador_errores++;
      }
      else if (state == -1)
      {
        // some other error occurred
        Serial.print(F("[SX1278] Failed, code "));
        Serial.println(state);
        contador_errores++;
      }
      else if (datacorrupta)
      {
        // some other error occurred
        Serial.print(F("[SX1278] Data corrupta..."));
        Serial.println(state);
        datacorrupta = false; ///Reinicio bandera
        contador_errores++;
      }

      Serial.print(F("[SX1278] Contador: "));
      Serial.println(contador);
      Serial.print(F("[SX1278] Contador error: "));
      Serial.println(contador_errores);

      Serial.println("");
    }
  else
  {
    Serial.println("Se estan enviando datos...");
  }
  vTaskSuspend(NULL);
  }
}

\end{lstlisting}